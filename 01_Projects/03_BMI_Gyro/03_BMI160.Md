To understand **how a BMI160 sensor provides data to the SDM660 SoC via SLPI**, you need to look at the **entire data pipeline**, from **device tree bindings** to **sensor driver registration, SLPI (Sensor Low Power Island) offloading**, and **FastRPC communication between the APPS processor (AP) and SLPI (DSP)**.

---

## 📦 High-Level Architecture Overview (SDM660 + BMI160)

```
        +---------------------+           +-------------------------+
        |    APPS Processor   |           |         SLPI           |
        |  (Linux Kernel)     |           |  (Sensor DSP)          |
        +---------------------+           +-------------------------+
                  |                                 ^
       (I2C Driver + Sensor HAL)                    | FastRPC
                  |                                 |
        +---------v----------+         +------------+-------------+
        |   I2C Controller   |<------->|   SLIMbus / I2C Master    |
        +--------------------+        | (sensor_intf, QUP3, etc)  |
                  ^                   +------------+-------------+
                  |                                |
        +---------+------------+                  |
        |   BMI160 Sensor      |<-----------------+
        +----------------------+
```

---

## 🔧 1. Device Tree: BMI160 on I2C

You're correctly configuring the **BMI160 sensor** on **I2C3** using the device tree (`msm-sdm660.dtsi`):

```dts
&i2c_3 {
    bmi160@68 {
        compatible = "bosch,bmi160";
        reg = <0x68>; // I2C address
        interrupt-parent = <&tlmm>; // GPIO interrupt controller
        interrupts = <23 IRQ_TYPE_EDGE_RISING>; // Interrupt from sensor
        vdd-supply = <&vreg_l7>; // Power rails
        vddio-supply = <&vreg_l5>;
    };
};
```

✔️ This configures:

* **I2C address** (`0x68`)
* **Interrupt GPIO line** for data-ready
* **Voltage regulators** for VDD and VDDIO

---

## 🔁 2. Who Uses This Device Tree?

In **Android/Linux**, this device tree config is mostly used by:

* **I2C client driver** on the **Application Processor (AP)**, or
* **Sensor subsystem firmware** on the **SLPI (Sensor DSP)**

In **SDM660**, most sensors (including BMI160) are **offloaded to SLPI** for low-power sensing.

---

## 🧠 3. What is SLPI (Sensor Low Power Island)?

* SLPI is a **low-power DSP domain** inside SDM660 SoC.
* It runs its own **QDSP firmware**, separate from Linux.
* It has direct access to **I2C/SPI buses** and **sensors**.
* Communicates with the AP over **FastRPC** or **QMI**.

Purpose:
✅ Keep sensors running while AP sleeps
✅ Report events (like motion, gestures) only when needed

---

## 📡 4. Sensor Data Flow (AP ↔ SLPI ↔ BMI160)

### Step-by-step Data Flow:

1. **Sensor Service on Android** requests data from `bmi160` (via Sensor HAL).
2. **Sensor HAL (on AP)** sends FastRPC request to **SLPI**.
3. **SLPI’s Sensor Manager** looks up the `bmi160` sensor config (usually loaded from a firmware config).
4. SLPI **configures the BMI160** over I2C3 via its own I2C master.
5. **BMI160 generates interrupt** when data is ready.
6. SLPI reads data, processes it (e.g., filter, fuse), and reports back to AP via **FastRPC callback or shared memory**.
7. Android app receives the **sensor event** from **SensorService → SensorManager**.

---

## 🛠️ 5. Where is the Driver?

On **Qualcomm SDM660**, BMI160 is typically **not handled by Linux kernel driver**.

Instead:

* The **sensor driver** (for BMI160) lives inside the **SLPI firmware image** (part of `modem` or `slpi` partitions).
* The **Linux driver** on AP just enables **FastRPC** communication (`sensors` driver, `sns_dsps`, `qcom_sensors`).

---

## 🔍 6. Configuration and Enablement

Sensor HAL or QMI client sends configuration to SLPI:

* Sampling rate
* FIFO size
* Interrupt threshold
* Power mode (normal/suspend)

SLPI programs:

* I2C to communicate with BMI160
* GPIO interrupt
* Internal timestamping
* Calibration/processing

---

## 📁 7. Related Files on Android/SDM660

* **Device Tree**: `msm-sdm660.dtsi`, `msm-i2c.dtsi`
* **Firmware Partition**: `slpi.mbn`, `slpi_ua.mbn`
* **Android HAL**: `android.hardware.sensors@1.0-impl.so`
* **FastRPC driver**: `adsp_loader`, `fastrpc`, `qcom_sensors`
* **Sensor config**: `sensor_def_qcomdev.conf`, `sensors/hub/registry/`

---

## 🧪 8. Debug Tips

* Check `/d/sensors/` or `/sys/bus/platform/drivers/qcom_sensors/`
* Use `logcat` tags: `Sensors`, `SensorHAL`, `SLPI`
* Dump FastRPC status: `cat /sys/kernel/debug/fastrpc/`

---

## 🧵 Summary

| Component     | Role                                                  |
| ------------- | ----------------------------------------------------- |
| Device Tree   | Declares BMI160 on I2C3                               |
| Kernel        | Registers fastrpc interface, not actual sensor driver |
| SLPI (DSP)    | Owns the BMI160 sensor, configures it via I2C         |
| Sensor HAL    | Talks to SLPI via FastRPC                             |
| BMI160 Sensor | Sends data via I2C + interrupt to SLPI                |

---

Great — since you're working with **Qualcomm SDM660**, SLPI, and sensor communication, understanding how **FastRPC** works using `.idl` files and client-server communication is essential. Here's a complete guide with example code for **FastRPC IDL-based communication** between the **Application Processor (AP)** and **SLPI (Sensor DSP)**.

---

## 📦 FastRPC Overview

FastRPC is Qualcomm's high-speed IPC mechanism between the **Application Processor (AP)** and **remote DSP subsystems** (like SLPI, ADSP).

* Uses **IDL (Interface Definition Language)** to define APIs.
* Generates code (stubs/skels) for **AP client and SLPI server**.
* Internally uses shared memory + QDSP FastRPC driver.

---

## 📁 1. Directory Layout (Qualcomm Standard)

```text
├── myrpc/
│   ├── mysensor.idl         ← Interface definition
│   ├── mysensor_app.c       ← Client code (APPS Processor)
│   ├── mysensor_skel.c      ← Server stub (Auto-generated)
│   ├── mysensor_stub.c      ← Client stub (Auto-generated)
│   ├── mysensor_dsp.c       ← Server logic (runs on SLPI)
```

---

## 📘 2. IDL File: `mysensor.idl`

```idl
interface mysensor {
    int32 read_accel(int32 *x, int32 *y, int32 *z);
};
```

💡 This defines a **function `read_accel()`** callable from AP, and implemented on SLPI, returning accelerometer data.

---

## ⚙️ 3. Generate Stub/Skel Code

Use Qualcomm’s `rpcgen` tool (part of Hexagon SDK):

```bash
rpcgen -I . -o mysensor mysensor.idl
```

Generates:

* `mysensor_stub.c` / `.h` → For AP client
* `mysensor_skel.c` / `.h` → For SLPI server

---

## 🧠 4. SLPI Side Server: `mysensor_dsp.c`

```c
#include "mysensor_skel.h"

int32 read_accel(int32 *x, int32 *y, int32 *z) {
    // Example values — in real case, read via I2C
    *x = 1024;
    *y = -512;
    *z = 256;
    return 0;
}
```

Compile with Hexagon toolchain (`qurt` or `hexagon-clang`) and link to `slpi.mbn`.

---

## 💻 5. AP Side Client (Linux/Android): `mysensor_app.c`

```c
#include <stdio.h>
#include <stdlib.h>
#include "mysensor.h"

int main() {
    int x, y, z;
    int ret = read_accel(&x, &y, &z);
    if (ret == 0) {
        printf("Accel: x=%d, y=%d, z=%d\n", x, y, z);
    } else {
        printf("Failed to get sensor data (ret=%d)\n", ret);
    }
    return 0;
}
```

Compile with normal `arm-linux-gcc` and run on Android/Linux.

---

## 📞 6. How It Works Internally

1. Your app (`mysensor_app`) uses FastRPC stub to call `read_accel()`.
2. Stub marshals arguments, sends via **FastRPC driver** to SLPI.
3. SLPI loads `mysensor_skel`, which dispatches to `read_accel()` server function.
4. Results are marshalled back and returned to user app.

---

## 🔎 7. FastRPC Setup on Target

Make sure:

* SLPI `.mbn` includes your DSP service.
* Driver node `/dev/fastrpc-smd` or `/dev/fastrpc-adsp` is present.
* Permissions set (use `chown` or `chmod`).
* `adsp_loader` and `fastrpc` kernel modules are loaded.

---

## 📂 8. Real Sensor Example

In production, your `read_accel()` will:

* Access **BMI160** via SLPI’s **I2C bus controller** (QUP).
* Possibly use **sensor driver framework** inside QDSP.
* Apply **scaling, calibration**, and **timestamping**.
* Return structured data to the AP.

---

## 🧪 9. Debug Tools

* Check `/sys/kernel/debug/fastrpc/`
* Use `logcat` with tag: `FastRPC`, `Sensors`, `adsp_loader`
* Validate RPC errors with return codes (`-1`, `-6`, etc.)

---

## ✅ Summary

| Component          | Description                                  |
| ------------------ | -------------------------------------------- |
| `.idl` file        | Declares callable API (e.g., `read_accel()`) |
| AP client (`.c`)   | Uses stub to make call to SLPI               |
| SLPI server (`.c`) | Implements the logic, runs on DSP            |
| FastRPC driver     | Transfers data using shared memory           |

---

Would you like:

* A working **sensor client + server template** to test?
* The full **build instructions using Hexagon SDK**?
* Or how this fits into **Qualcomm's sensor framework** on SLPI?

Let me know what depth you want next.
