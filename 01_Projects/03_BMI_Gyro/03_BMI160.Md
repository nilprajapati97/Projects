To understand **how a BMI160 sensor provides data to the SDM660 SoC via SLPI**, you need to look at the **entire data pipeline**, from **device tree bindings** to **sensor driver registration, SLPI (Sensor Low Power Island) offloading**, and **FastRPC communication between the APPS processor (AP) and SLPI (DSP)**.

---

## ğŸ“¦ High-Level Architecture Overview (SDM660 + BMI160)

```
        +---------------------+           +-------------------------+
        |    APPS Processor   |           |         SLPI           |
        |  (Linux Kernel)     |           |  (Sensor DSP)          |
        +---------------------+           +-------------------------+
                  |                                 ^
       (I2C Driver + Sensor HAL)                    | FastRPC
                  |                                 |
        +---------v----------+         +------------+-------------+
        |   I2C Controller   |<------->|   SLIMbus / I2C Master    |
        +--------------------+        | (sensor_intf, QUP3, etc)  |
                  ^                   +------------+-------------+
                  |                                |
        +---------+------------+                  |
        |   BMI160 Sensor      |<-----------------+
        +----------------------+
```

---

## ğŸ”§ 1. Device Tree: BMI160 on I2C

You're correctly configuring the **BMI160 sensor** on **I2C3** using the device tree (`msm-sdm660.dtsi`):

```dts
&i2c_3 {
    bmi160@68 {
        compatible = "bosch,bmi160";
        reg = <0x68>; // I2C address
        interrupt-parent = <&tlmm>; // GPIO interrupt controller
        interrupts = <23 IRQ_TYPE_EDGE_RISING>; // Interrupt from sensor
        vdd-supply = <&vreg_l7>; // Power rails
        vddio-supply = <&vreg_l5>;
    };
};
```

âœ”ï¸ This configures:

* **I2C address** (`0x68`)
* **Interrupt GPIO line** for data-ready
* **Voltage regulators** for VDD and VDDIO

---

## ğŸ” 2. Who Uses This Device Tree?

In **Android/Linux**, this device tree config is mostly used by:

* **I2C client driver** on the **Application Processor (AP)**, or
* **Sensor subsystem firmware** on the **SLPI (Sensor DSP)**

In **SDM660**, most sensors (including BMI160) are **offloaded to SLPI** for low-power sensing.

---

## ğŸ§  3. What is SLPI (Sensor Low Power Island)?

* SLPI is a **low-power DSP domain** inside SDM660 SoC.
* It runs its own **QDSP firmware**, separate from Linux.
* It has direct access to **I2C/SPI buses** and **sensors**.
* Communicates with the AP over **FastRPC** or **QMI**.

Purpose:
âœ… Keep sensors running while AP sleeps
âœ… Report events (like motion, gestures) only when needed

---

## ğŸ“¡ 4. Sensor Data Flow (AP â†” SLPI â†” BMI160)

### Step-by-step Data Flow:

1. **Sensor Service on Android** requests data from `bmi160` (via Sensor HAL).
2. **Sensor HAL (on AP)** sends FastRPC request to **SLPI**.
3. **SLPIâ€™s Sensor Manager** looks up the `bmi160` sensor config (usually loaded from a firmware config).
4. SLPI **configures the BMI160** over I2C3 via its own I2C master.
5. **BMI160 generates interrupt** when data is ready.
6. SLPI reads data, processes it (e.g., filter, fuse), and reports back to AP via **FastRPC callback or shared memory**.
7. Android app receives the **sensor event** from **SensorService â†’ SensorManager**.

---

## ğŸ› ï¸ 5. Where is the Driver?

On **Qualcomm SDM660**, BMI160 is typically **not handled by Linux kernel driver**.

Instead:

* The **sensor driver** (for BMI160) lives inside the **SLPI firmware image** (part of `modem` or `slpi` partitions).
* The **Linux driver** on AP just enables **FastRPC** communication (`sensors` driver, `sns_dsps`, `qcom_sensors`).

---

## ğŸ” 6. Configuration and Enablement

Sensor HAL or QMI client sends configuration to SLPI:

* Sampling rate
* FIFO size
* Interrupt threshold
* Power mode (normal/suspend)

SLPI programs:

* I2C to communicate with BMI160
* GPIO interrupt
* Internal timestamping
* Calibration/processing

---

## ğŸ“ 7. Related Files on Android/SDM660

* **Device Tree**: `msm-sdm660.dtsi`, `msm-i2c.dtsi`
* **Firmware Partition**: `slpi.mbn`, `slpi_ua.mbn`
* **Android HAL**: `android.hardware.sensors@1.0-impl.so`
* **FastRPC driver**: `adsp_loader`, `fastrpc`, `qcom_sensors`
* **Sensor config**: `sensor_def_qcomdev.conf`, `sensors/hub/registry/`

---

## ğŸ§ª 8. Debug Tips

* Check `/d/sensors/` or `/sys/bus/platform/drivers/qcom_sensors/`
* Use `logcat` tags: `Sensors`, `SensorHAL`, `SLPI`
* Dump FastRPC status: `cat /sys/kernel/debug/fastrpc/`

---

## ğŸ§µ Summary

| Component     | Role                                                  |
| ------------- | ----------------------------------------------------- |
| Device Tree   | Declares BMI160 on I2C3                               |
| Kernel        | Registers fastrpc interface, not actual sensor driver |
| SLPI (DSP)    | Owns the BMI160 sensor, configures it via I2C         |
| Sensor HAL    | Talks to SLPI via FastRPC                             |
| BMI160 Sensor | Sends data via I2C + interrupt to SLPI                |

---

Great â€” since you're working with **Qualcomm SDM660**, SLPI, and sensor communication, understanding how **FastRPC** works using `.idl` files and client-server communication is essential. Here's a complete guide with example code for **FastRPC IDL-based communication** between the **Application Processor (AP)** and **SLPI (Sensor DSP)**.

---

## ğŸ“¦ FastRPC Overview

FastRPC is Qualcomm's high-speed IPC mechanism between the **Application Processor (AP)** and **remote DSP subsystems** (like SLPI, ADSP).

* Uses **IDL (Interface Definition Language)** to define APIs.
* Generates code (stubs/skels) for **AP client and SLPI server**.
* Internally uses shared memory + QDSP FastRPC driver.

---

## ğŸ“ 1. Directory Layout (Qualcomm Standard)

```text
â”œâ”€â”€ myrpc/
â”‚   â”œâ”€â”€ mysensor.idl         â† Interface definition
â”‚   â”œâ”€â”€ mysensor_app.c       â† Client code (APPS Processor)
â”‚   â”œâ”€â”€ mysensor_skel.c      â† Server stub (Auto-generated)
â”‚   â”œâ”€â”€ mysensor_stub.c      â† Client stub (Auto-generated)
â”‚   â”œâ”€â”€ mysensor_dsp.c       â† Server logic (runs on SLPI)
```

---

## ğŸ“˜ 2. IDL File: `mysensor.idl`

```idl
interface mysensor {
    int32 read_accel(int32 *x, int32 *y, int32 *z);
};
```

ğŸ’¡ This defines a **function `read_accel()`** callable from AP, and implemented on SLPI, returning accelerometer data.

---

## âš™ï¸ 3. Generate Stub/Skel Code

Use Qualcommâ€™s `rpcgen` tool (part of Hexagon SDK):

```bash
rpcgen -I . -o mysensor mysensor.idl
```

Generates:

* `mysensor_stub.c` / `.h` â†’ For AP client
* `mysensor_skel.c` / `.h` â†’ For SLPI server

---

## ğŸ§  4. SLPI Side Server: `mysensor_dsp.c`

```c
#include "mysensor_skel.h"

int32 read_accel(int32 *x, int32 *y, int32 *z) {
    // Example values â€” in real case, read via I2C
    *x = 1024;
    *y = -512;
    *z = 256;
    return 0;
}
```

Compile with Hexagon toolchain (`qurt` or `hexagon-clang`) and link to `slpi.mbn`.

---

## ğŸ’» 5. AP Side Client (Linux/Android): `mysensor_app.c`

```c
#include <stdio.h>
#include <stdlib.h>
#include "mysensor.h"

int main() {
    int x, y, z;
    int ret = read_accel(&x, &y, &z);
    if (ret == 0) {
        printf("Accel: x=%d, y=%d, z=%d\n", x, y, z);
    } else {
        printf("Failed to get sensor data (ret=%d)\n", ret);
    }
    return 0;
}
```

Compile with normal `arm-linux-gcc` and run on Android/Linux.

---

## ğŸ“ 6. How It Works Internally

1. Your app (`mysensor_app`) uses FastRPC stub to call `read_accel()`.
2. Stub marshals arguments, sends via **FastRPC driver** to SLPI.
3. SLPI loads `mysensor_skel`, which dispatches to `read_accel()` server function.
4. Results are marshalled back and returned to user app.

---

## ğŸ” 7. FastRPC Setup on Target

Make sure:

* SLPI `.mbn` includes your DSP service.
* Driver node `/dev/fastrpc-smd` or `/dev/fastrpc-adsp` is present.
* Permissions set (use `chown` or `chmod`).
* `adsp_loader` and `fastrpc` kernel modules are loaded.

---

## ğŸ“‚ 8. Real Sensor Example

In production, your `read_accel()` will:

* Access **BMI160** via SLPIâ€™s **I2C bus controller** (QUP).
* Possibly use **sensor driver framework** inside QDSP.
* Apply **scaling, calibration**, and **timestamping**.
* Return structured data to the AP.

---

## ğŸ§ª 9. Debug Tools

* Check `/sys/kernel/debug/fastrpc/`
* Use `logcat` with tag: `FastRPC`, `Sensors`, `adsp_loader`
* Validate RPC errors with return codes (`-1`, `-6`, etc.)

---

## âœ… Summary

| Component          | Description                                  |
| ------------------ | -------------------------------------------- |
| `.idl` file        | Declares callable API (e.g., `read_accel()`) |
| AP client (`.c`)   | Uses stub to make call to SLPI               |
| SLPI server (`.c`) | Implements the logic, runs on DSP            |
| FastRPC driver     | Transfers data using shared memory           |

---

Would you like:

* A working **sensor client + server template** to test?
* The full **build instructions using Hexagon SDK**?
* Or how this fits into **Qualcomm's sensor framework** on SLPI?

Let me know what depth you want next.
